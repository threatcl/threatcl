package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.55

import (
	"context"

	"github.com/threatcl/spec"
)

// Key is the resolver for the key field.
func (r *additionalAttributeResolver) Key(ctx context.Context, obj *spec.AdditionalAttribute) (string, error) {
	return obj.Name, nil
}

// Processes is the resolver for the processes field.
func (r *dataFlowDiagramResolver) Processes(ctx context.Context, obj *spec.DataFlowDiagram) ([]*Process, error) {
	return MapProcessesToGraphQL(obj.Processes), nil
}

// DataStores is the resolver for the dataStores field.
func (r *dataFlowDiagramResolver) DataStores(ctx context.Context, obj *spec.DataFlowDiagram) ([]*DataStore, error) {
	return MapDataStoresToGraphQL(obj.DataStores), nil
}

// ExternalElements is the resolver for the externalElements field.
func (r *dataFlowDiagramResolver) ExternalElements(ctx context.Context, obj *spec.DataFlowDiagram) ([]*ExternalElement, error) {
	return MapExternalElementsToGraphQL(obj.ExternalElements), nil
}

// Flows is the resolver for the flows field.
func (r *dataFlowDiagramResolver) Flows(ctx context.Context, obj *spec.DataFlowDiagram) ([]*Flow, error) {
	return MapFlowsToGraphQL(obj.Flows), nil
}

// TrustZones is the resolver for the trustZones field.
func (r *dataFlowDiagramResolver) TrustZones(ctx context.Context, obj *spec.DataFlowDiagram) ([]*TrustZone, error) {
	return MapTrustZonesToGraphQL(obj.TrustZones), nil
}

// ThreatModel is the resolver for the threatModel field.
func (r *informationAssetResolver) ThreatModel(ctx context.Context, obj *spec.InformationAsset) (*ThreatModel, error) {
	// Find which threat model this asset belongs to
	allModels := r.Cache.GetAll()
	for _, tm := range allModels {
		for _, asset := range tm.InformationAssets {
			if asset == obj {
				sourceFile, _ := r.Cache.GetSourceFile(tm.Name)
				return MapThreatModelToGraphQL(tm, sourceFile), nil
			}
		}
	}
	return nil, nil
}

// ThreatModels is the resolver for the threatModels field.
func (r *queryResolver) ThreatModels(ctx context.Context, filter *ThreatModelFilter) ([]*ThreatModel, error) {
	allModels := r.Cache.GetAll()

	// Apply filtering
	filtered := []*ThreatModel{}
	for _, tm := range allModels {
		if matchesFilter(tm, filter) {
			sourceFile, _ := r.Cache.GetSourceFile(tm.Name)
			graphqlModel := MapThreatModelToGraphQL(tm, sourceFile)
			filtered = append(filtered, graphqlModel)
		}
	}

	return filtered, nil
}

// ThreatModel is the resolver for the threatModel field.
func (r *queryResolver) ThreatModel(ctx context.Context, name string) (*ThreatModel, error) {
	tm, err := r.Cache.Get(name)
	if err != nil {
		return nil, nil // Return nil instead of error for not found (GraphQL pattern)
	}

	sourceFile, _ := r.Cache.GetSourceFile(name)
	return MapThreatModelToGraphQL(tm, sourceFile), nil
}

// Threats is the resolver for the threats field.
func (r *queryResolver) Threats(ctx context.Context, filter *ThreatFilter) ([]*spec.Threat, error) {
	allModels := r.Cache.GetAll()
	threats := []*spec.Threat{}

	for _, tm := range allModels {
		for _, threat := range tm.Threats {
			if matchesThreatFilter(threat, filter) {
				threats = append(threats, threat)
			}
		}
	}

	return threats, nil
}

// InformationAssets is the resolver for the informationAssets field.
func (r *queryResolver) InformationAssets(ctx context.Context, classification *string) ([]*spec.InformationAsset, error) {
	allModels := r.Cache.GetAll()
	assets := []*spec.InformationAsset{}

	for _, tm := range allModels {
		for _, asset := range tm.InformationAssets {
			if classification == nil || asset.InformationClassification == *classification {
				assets = append(assets, asset)
			}
		}
	}

	return assets, nil
}

// Stats is the resolver for the stats field.
func (r *queryResolver) Stats(ctx context.Context) (*Statistics, error) {
	allModels := r.Cache.GetAll()

	stats := &Statistics{
		TotalThreatModels: len(allModels),
	}

	totalRiskReduction := 0
	riskReductionCount := 0

	for _, tm := range allModels {
		stats.TotalInformationAssets += len(tm.InformationAssets)
		stats.TotalThreats += len(tm.Threats)

		for _, threat := range tm.Threats {
			for _, control := range threat.Controls {
				stats.TotalControls++
				if control.Implemented {
					stats.ImplementedControls++
				}
				if control.RiskReduction > 0 {
					totalRiskReduction += control.RiskReduction
					riskReductionCount++
				}
			}
		}
	}

	if riskReductionCount > 0 {
		avgRisk := float64(totalRiskReduction) / float64(riskReductionCount)
		stats.AverageRiskReduction = &avgRisk
	}

	return stats, nil
}

// UptimeDependency is the resolver for the uptimeDependency field.
func (r *thirdPartyDependencyResolver) UptimeDependency(ctx context.Context, obj *spec.ThirdPartyDependency) (string, error) {
	return string(obj.UptimeDependency), nil
}

// Impacts is the resolver for the impacts field.
func (r *threatResolver) Impacts(ctx context.Context, obj *spec.Threat) ([]string, error) {
	if obj.ImpactType == nil {
		return []string{}, nil
	}
	return obj.ImpactType, nil
}

// ThreatModel is the resolver for the threatModel field.
func (r *threatResolver) ThreatModel(ctx context.Context, obj *spec.Threat) (*ThreatModel, error) {
	// Find which threat model this threat belongs to by matching threat name
	allModels := r.Cache.GetAll()
	for _, tm := range allModels {
		for _, threat := range tm.Threats {
			if threat.Name == obj.Name {
				sourceFile, _ := r.Cache.GetSourceFile(tm.Name)
				return MapThreatModelToGraphQL(tm, sourceFile), nil
			}
		}
	}
	return nil, nil
}

// AdditionalAttribute returns AdditionalAttributeResolver implementation.
func (r *Resolver) AdditionalAttribute() AdditionalAttributeResolver {
	return &additionalAttributeResolver{r}
}

// DataFlowDiagram returns DataFlowDiagramResolver implementation.
func (r *Resolver) DataFlowDiagram() DataFlowDiagramResolver { return &dataFlowDiagramResolver{r} }

// InformationAsset returns InformationAssetResolver implementation.
func (r *Resolver) InformationAsset() InformationAssetResolver { return &informationAssetResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// ThirdPartyDependency returns ThirdPartyDependencyResolver implementation.
func (r *Resolver) ThirdPartyDependency() ThirdPartyDependencyResolver {
	return &thirdPartyDependencyResolver{r}
}

// Threat returns ThreatResolver implementation.
func (r *Resolver) Threat() ThreatResolver { return &threatResolver{r} }

type additionalAttributeResolver struct{ *Resolver }
type dataFlowDiagramResolver struct{ *Resolver }
type informationAssetResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type thirdPartyDependencyResolver struct{ *Resolver }
type threatResolver struct{ *Resolver }
