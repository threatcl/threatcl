package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.55

import (
	"context"

	"github.com/threatcl/spec"
)

// Key is the resolver for the key field.
func (r *additionalAttributeResolver) Key(ctx context.Context, obj *spec.AdditionalAttribute) (string, error) {
	return obj.Name, nil
}

// Processes is the resolver for the processes field.
func (r *dataFlowDiagramResolver) Processes(ctx context.Context, obj *spec.DataFlowDiagram) ([]*Process, error) {
	return MapProcessesToGraphQL(obj.Processes), nil
}

// DataStores is the resolver for the dataStores field.
func (r *dataFlowDiagramResolver) DataStores(ctx context.Context, obj *spec.DataFlowDiagram) ([]*DataStore, error) {
	return MapDataStoresToGraphQL(obj.DataStores), nil
}

// ExternalElements is the resolver for the externalElements field.
func (r *dataFlowDiagramResolver) ExternalElements(ctx context.Context, obj *spec.DataFlowDiagram) ([]*ExternalElement, error) {
	return MapExternalElementsToGraphQL(obj.ExternalElements), nil
}

// Flows is the resolver for the flows field.
func (r *dataFlowDiagramResolver) Flows(ctx context.Context, obj *spec.DataFlowDiagram) ([]*Flow, error) {
	return MapFlowsToGraphQL(obj.Flows), nil
}

// TrustZones is the resolver for the trustZones field.
func (r *dataFlowDiagramResolver) TrustZones(ctx context.Context, obj *spec.DataFlowDiagram) ([]*TrustZone, error) {
	return MapTrustZonesToGraphQL(obj.TrustZones), nil
}

// ThreatModel is the resolver for the threatModel field.
func (r *informationAssetResolver) ThreatModel(ctx context.Context, obj *spec.InformationAsset) (*ThreatModel, error) {
	// Find which threat model this asset belongs to
	allModels := r.Cache.GetAll()
	for _, tm := range allModels {
		for _, asset := range tm.InformationAssets {
			if asset == obj {
				sourceFile, _ := r.Cache.GetSourceFile(tm.Name)
				return MapThreatModelToGraphQL(tm, sourceFile), nil
			}
		}
	}
	return nil, nil
}

// ThreatModels is the resolver for the threatModels field.
func (r *queryResolver) ThreatModels(ctx context.Context, filter *ThreatModelFilter) ([]*ThreatModel, error) {
	allModels := r.Cache.GetAll()

	// Apply filtering
	filtered := []*ThreatModel{}
	for _, tm := range allModels {
		if matchesFilter(tm, filter) {
			sourceFile, _ := r.Cache.GetSourceFile(tm.Name)
			graphqlModel := MapThreatModelToGraphQL(tm, sourceFile)
			filtered = append(filtered, graphqlModel)
		}
	}

	return filtered, nil
}

// ThreatModel is the resolver for the threatModel field.
func (r *queryResolver) ThreatModel(ctx context.Context, name string) (*ThreatModel, error) {
	tm, err := r.Cache.Get(name)
	if err != nil {
		return nil, nil // Return nil instead of error for not found (GraphQL pattern)
	}

	sourceFile, _ := r.Cache.GetSourceFile(name)
	return MapThreatModelToGraphQL(tm, sourceFile), nil
}

// Threats is the resolver for the threats field.
func (r *queryResolver) Threats(ctx context.Context, filter *ThreatFilter) ([]*spec.Threat, error) {
	allModels := r.Cache.GetAll()
	threats := []*spec.Threat{}

	for _, tm := range allModels {
		for _, threat := range tm.Threats {
			if matchesThreatFilter(threat, filter) {
				threats = append(threats, threat)
			}
		}
	}

	return threats, nil
}

// InformationAssets is the resolver for the informationAssets field.
func (r *queryResolver) InformationAssets(ctx context.Context, classification *string) ([]*spec.InformationAsset, error) {
	allModels := r.Cache.GetAll()
	assets := []*spec.InformationAsset{}

	for _, tm := range allModels {
		for _, asset := range tm.InformationAssets {
			if classification == nil || asset.InformationClassification == *classification {
				assets = append(assets, asset)
			}
		}
	}

	return assets, nil
}

// Stats is the resolver for the stats field.
func (r *queryResolver) Stats(ctx context.Context) (*Statistics, error) {
	allModels := r.Cache.GetAll()

	stats := &Statistics{
		TotalThreatModels: len(allModels),
	}

	totalRiskReduction := 0
	riskReductionCount := 0

	for _, tm := range allModels {
		stats.TotalInformationAssets += len(tm.InformationAssets)
		stats.TotalThreats += len(tm.Threats)

		for _, threat := range tm.Threats {
			for _, control := range threat.Controls {
				stats.TotalControls++
				if control.Implemented {
					stats.ImplementedControls++
				}
				if control.RiskReduction > 0 {
					totalRiskReduction += control.RiskReduction
					riskReductionCount++
				}
			}
		}
	}

	if riskReductionCount > 0 {
		avgRisk := float64(totalRiskReduction) / float64(riskReductionCount)
		stats.AverageRiskReduction = &avgRisk
	}

	return stats, nil
}

// UptimeDependency is the resolver for the uptimeDependency field.
func (r *thirdPartyDependencyResolver) UptimeDependency(ctx context.Context, obj *spec.ThirdPartyDependency) (string, error) {
	return string(obj.UptimeDependency), nil
}

// Impacts is the resolver for the impacts field.
func (r *threatResolver) Impacts(ctx context.Context, obj *spec.Threat) ([]string, error) {
	if obj.ImpactType == nil {
		return []string{}, nil
	}
	return obj.ImpactType, nil
}

// ThreatModel is the resolver for the threatModel field.
func (r *threatResolver) ThreatModel(ctx context.Context, obj *spec.Threat) (*ThreatModel, error) {
	// Find which threat model this threat belongs to
	allModels := r.Cache.GetAll()
	for _, tm := range allModels {
		for _, threat := range tm.Threats {
			if threat == obj {
				sourceFile, _ := r.Cache.GetSourceFile(tm.Name)
				return MapThreatModelToGraphQL(tm, sourceFile), nil
			}
		}
	}
	return nil, nil
}

// AdditionalAttribute returns AdditionalAttributeResolver implementation.
func (r *Resolver) AdditionalAttribute() AdditionalAttributeResolver {
	return &additionalAttributeResolver{r}
}

// DataFlowDiagram returns DataFlowDiagramResolver implementation.
func (r *Resolver) DataFlowDiagram() DataFlowDiagramResolver { return &dataFlowDiagramResolver{r} }

// InformationAsset returns InformationAssetResolver implementation.
func (r *Resolver) InformationAsset() InformationAssetResolver { return &informationAssetResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// ThirdPartyDependency returns ThirdPartyDependencyResolver implementation.
func (r *Resolver) ThirdPartyDependency() ThirdPartyDependencyResolver {
	return &thirdPartyDependencyResolver{r}
}

// Threat returns ThreatResolver implementation.
func (r *Resolver) Threat() ThreatResolver { return &threatResolver{r} }

type additionalAttributeResolver struct{ *Resolver }
type dataFlowDiagramResolver struct{ *Resolver }
type informationAssetResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type thirdPartyDependencyResolver struct{ *Resolver }
type threatResolver struct{ *Resolver }

// Helper functions for filtering

// matchesFilter checks if a threat model matches the given filter
func matchesFilter(tm *spec.Threatmodel, filter *ThreatModelFilter) bool {
	if filter == nil {
		return true
	}

	// Check author filter
	if filter.Author != nil && tm.Author != *filter.Author {
		return false
	}

	// Check attributes-based filters
	if tm.Attributes != nil {
		if filter.InternetFacing != nil && tm.Attributes.InternetFacing != *filter.InternetFacing {
			return false
		}

		if filter.NewInitiative != nil && tm.Attributes.NewInitiative != *filter.NewInitiative {
			return false
		}

		if filter.InitiativeSize != nil && tm.Attributes.InitiativeSize != *filter.InitiativeSize {
			return false
		}
	} else {
		// If model has no attributes but filter requires them, it doesn't match
		if filter.InternetFacing != nil || filter.NewInitiative != nil || filter.InitiativeSize != nil {
			return false
		}
	}

	return true
}

// matchesThreatFilter checks if a threat matches the given filter
func matchesThreatFilter(threat *spec.Threat, filter *ThreatFilter) bool {
	if filter == nil {
		return true
	}

	// Check impacts filter
	if len(filter.Impacts) > 0 {
		if !containsAny(threat.ImpactType, filter.Impacts) {
			return false
		}
	}

	// Check STRIDE filter
	if len(filter.Stride) > 0 {
		if !containsAny(threat.Stride, filter.Stride) {
			return false
		}
	}

	// Check hasImplementedControls filter
	if filter.HasImplementedControls != nil {
		hasImplemented := false
		for _, control := range threat.Controls {
			if control.Implemented {
				hasImplemented = true
				break
			}
		}
		if hasImplemented != *filter.HasImplementedControls {
			return false
		}
	}

	return true
}

// containsAny checks if slice a contains any element from slice b
func containsAny(a, b []string) bool {
	if len(a) == 0 {
		return false
	}
	for _, itemB := range b {
		for _, itemA := range a {
			if itemA == itemB {
				return true
			}
		}
	}
	return false
}
